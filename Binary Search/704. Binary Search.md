# 704. Binary Search

Completed on: 2021-12-28
- - - 
## Problem 
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
 
You must write an algorithm with O(log n) runtime complexity.
- - - 
## Solution
### Framework
1. Repeat the problem. Redefine the problem in your own words to make sure you really understand the problem. ask interviewer if your understanding is correct. Understand the inputs and the outputs 
	- Sorted array
	- Search for target in nums with O(logn) time complexity
2. Create some examples with their inputs and outputs. Create a small table with inputs and outputs. See if your understanding holds true. Think about edge cases. this step is like test driven development. Start drawing. Use drawings to convey your thinking and what you are doing 
	| Input | Output|
    |----|----|
    Nums = [6], target = 6 | 0
	nums = [-1,5,9,12], target = 9 | 4
	nums = [-1,0,3,5,9,12], target = 2 | -1
3. Breakdown problems into steps (in plain english) that you'd take to solve the problem. Everything is at a high level, this prevents you from getting caught up in low level details, debugging, and implementation 
	- Implement binary search
4. Iterate on this Englished algorithm 
5. Translate steps into code. Usually it's ok to start with Brute force solution 
	- Pythonic: return nums.index(target) if target in nums else -1
	- Other brute force: loop through array and check if ==target
6. Draw a star next to code youre not sure about and that you'll revisit 
7. Test. Walk through your code with a few examples 
8. Optimization. Think about time and space complexity.  
    if nums[0] > target or nums[-1] < target:
        return -1

### Code
    class Solution:
    def search(self, nums: List[int], target: int) -> int:
        """return index of target if target is in nums, else return -1"""        
        # Iterative approach
        start = 0
        end = len(nums) - 1
        mid = start + (end-start)// 2
        
        while start <= end:
            if target == nums[mid]:
                return mid
            elif target < nums[mid]:
                end = mid - 1
                mid = start + (end-start)// 2
            else:
                start = mid + 1
                mid = start + (end-start)// 2
        return -1

    # recursive solution
    def search(self, nums: List[int], target: int) -> int:
        """return index of target if target is in nums, else return -1"""  
        return self.bin_search(nums, target, 0, len(nums)-1)
    
    def bin_search(self, nums: List[int], target: int, start: int, end: int) -> int:
        mid = start + (end-start)// 2

        if start <= end:
            # Stopping conditions
            if target == nums[mid]:
                return mid
            elif target < nums[mid]:
                end = mid - 1
                return self.bin_search(nums, target, start, end)
            else:
                start = mid + 1
                return self.bin_search(nums, target, start, end)
        return -1