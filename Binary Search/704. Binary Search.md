# 704. Binary Search

Completed on: 2021-12-28

## Problem 
- - -
Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.
 
You must write an algorithm with O(log n) runtime complexity.

## Solution
- - - 
### Framework
1. Repeat the problem. Redefine the problem in your own words to make sure you really understand the problem. ask interviewer if your understanding is correct. Understand the inputs and the outputs 
	- Sorted array
	- Search for target in nums with O(logn) time complexity
2. Create some examples with their inputs and outputs. Create a small table with inputs and outputs. See if your understanding holds true. Think about edge cases. this step is like test driven development. Start drawing. Use drawings to convey your thinking and what you are doing 
	| Input | Output|
    |----|----|
    Nums = [6], target = 6 | 0
	nums = [-1,5,9,12], target = 9 | 4
	nums = [-1,0,3,5,9,12], target = 2 | -1
3. Breakdown problems into steps (in plain english) that you'd take to solve the problem. Everything is at a high level, this prevents you from getting caught up in low level details, debugging, and implementation 
	- Implement binary search
4. Iterate on this Englished algorithm 
5. Translate steps into code. Usually it's ok to start with Brute force solution 
	- Pythonic: return nums.index(target) if target in nums else -1
	- Other brute force: loop through array and check if ==target
6. Draw a star next to code youre not sure about and that you'll revisit 
7. Test. Walk through your code with a few examples 
8. Optimization. Think about time and space complexity.  
    if nums[0] > target or nums[-1] < target:
        return -1

### Code
    class Solution:
    def search(self, nums: List[int], target: int) -> int:
        """return index of target if target is in nums, else return -1"""        
        # Iterative approach
        start = 0
        end = len(nums) - 1
        mid = start + (end-start)// 2
        
        while start <= end:
            if target == nums[mid]:
                return mid
            elif target < nums[mid]:
                end = mid - 1
                mid = start + (end-start)// 2
            else:
                start = mid + 1
                mid = start + (end-start)// 2
        return -1

    # recursive solution
    def search(self, nums: List[int], target: int) -> int:
        """return index of target if target is in nums, else return -1"""  
        return self.bin_search(nums, target, 0, len(nums)-1)
    
    def bin_search(self, nums: List[int], target: int, start: int, end: int) -> int:
        mid = start + (end-start)// 2

        if start <= end:
            # Stopping conditions
            if target == nums[mid]:
                return mid
            elif target < nums[mid]:
                end = mid - 1
                return self.bin_search(nums, target, start, end)
            else:
                start = mid + 1
                return self.bin_search(nums, target, start, end)
        return -1


# Notes:
- Binary Search is generally composed of 3 main sections:
    1. Pre-processing - Sort if collection is unsorted.
    2. Binary Search - Using a loop or recursion to divide search space in half after each comparison.
    3. Post-processing - Determine viable candidates in the remaining space.  

    From <https://leetcode.com/explore/learn/card/binary-search/138/background/974/>

- Binary search explained: https://www.code-recipe.com/post/binary-search
- One thing that tripped me up initially is that the start and end indices are updated as mid+1 and mid-1, respectively, instead of just ==mid. 
- Mid calculations: 
	mid = (left+right)/2, can result in overflow for large arrays. Instead, we should use
	mid = left + (right-left)/2
- Recursion: All recursive funcitons share a common structure made up of two parts:
    1. Recursive case
        - Decompose original problem into simpler instances of the same problem
    2. Base case / Stopping conditions
        - Smallest instance of the same problem
 
